{
package parser

type Program struct {
    Command *Command
}

type Command struct {
    Name string
    Arguments []string
}
}

// Comment goes.
program = _ command:command _ {
    return &Program{command.(*Command)}, nil
}

command = name:name _ argument:argument? {
    var arguments []string
    if argument!=nil{
        arguments = append(arguments, argument.(string))
    }
    return &Command{
        Name: name.(string),
        Arguments: arguments,
    }, nil
}

name = [^ \n\t\r]+ {
    // Without this action, the representation of this data in the resulting
    // AST would be in the form of array of array of byte. This single line
    // changes the result of matching this rule to a single string.
    return strings.TrimSpace(string(c.text)), nil
}

argument = [^ \n\t\r]+ {
    // Without this action, the representation of this data in the resulting
    // AST would be in the form of array of array of byte. This single line
    // changes the result of matching this rule to a single string.
    return strings.TrimSpace(string(c.text)), nil
}

// The whitespace rule is used to capture whitespace. Most grammars that I
// build are not whitespace sensitive, so the results of matching this will
// normally be discarded somehow.
_ "whitespace" <- [ \n\t\r]*
