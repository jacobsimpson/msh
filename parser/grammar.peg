{
package parser

}

// Comment goes.
program = _ EOF {
    return &Program{&Command{}}, nil
} / _ command:command _ EOF {
    return &Program{command.(*Command)}, nil
}

command = name:name arguments:(_ argument)* redirection:(_ redirection)? {
    var result []string
    if arguments != nil {
        for _, p := range arguments.([]interface{}) {
            a := p.([]interface{})
            result = append(result, a[1].(string))
        }
    }
    return &Command{
        Name:        name.(string),
        Arguments:   result,
        Redirection: getRedirection(redirection),
    }, nil
}

name = [^ \n\t\r>]+ {
    // Without this action, the representation of this data in the resulting
    // AST would be in the form of array of array of bytes. This single line
    // changes the result of matching this rule to a single string.
    return strings.TrimSpace(string(c.text)), nil
}

argument = argument:(double_quoted_string / single_quoted_string / word) {
    return argument, nil
}

redirection = '>' _ target:argument {
    return &Redirection{
        Target: target.(string),
        Type:   Truncate,
    }, nil
}

word = [^ \n\t\r>]+ {
    // Without this action, the representation of this data in the resulting
    // AST would be in the form of array of array of bytes. This single line
    // changes the result of matching this rule to a single string.
    return strings.TrimSpace(string(c.text)), nil
}

double_quoted_string = '"' [^"]* '"' {
    s := string(c.text)
    return s[1:len(s)-1], nil
}

single_quoted_string = "'" [^']* "'" {
    s := string(c.text)
    return s[1:len(s)-1], nil
}

// The whitespace rule is used to capture whitespace. Most grammars that I
// build are not whitespace sensitive, so the results of matching this will
// normally be discarded somehow.
_ "whitespace" <- [ \n\t\r]*

// An EOF character is anything that is not a character.
EOF = !.
